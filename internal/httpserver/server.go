package httpserver

import (
    "fmt"
    "log/slog"
    "net/http"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/go-chi/cors"
    "github.com/go-chi/httprate"
    httpSwagger "github.com/swaggo/http-swagger/v2"
    docs "github.com/mikko-kohtala/go-api/internal/docs"

    "github.com/mikko-kohtala/go-api/internal/config"
    "github.com/mikko-kohtala/go-api/internal/handlers"
    pkglogger "github.com/mikko-kohtala/go-api/pkg/logger"
)

// NewRouter assembles the chi router with middleware and routes.
func NewRouter(cfg *config.Config, appLogger *slog.Logger) http.Handler {
    r := chi.NewRouter()

    // Core middleware (place timeout early to bound all work)
    r.Use(middleware.Timeout(cfg.RequestTimeout))
    r.Use(BodyLimit(cfg.BodyLimitBytes))
    r.Use(RequestID)
    r.Use(middleware.RealIP)
    // Compression level is configurable
    r.Use(middleware.Compress(cfg.CompressionLevel))
    r.Use(LoggingMiddleware(appLogger))
    r.Use(middleware.Recoverer)

    // CORS
    r.Use(cors.Handler(cors.Options{
        AllowedOrigins:   cfg.CORSAllowedOrigins,
        AllowedMethods:   cfg.CORSAllowedMethods,
        AllowedHeaders:   cfg.CORSAllowedHeaders,
        ExposedHeaders:   []string{"Link"},
        AllowCredentials: false,
        MaxAge:           300,
    }))
    // Warn if permissive CORS in production
    if cfg.Env == "production" || cfg.Env == "prod" {
        for _, o := range cfg.CORSAllowedOrigins {
            if o == "*" {
                appLogger.Warn("CORS allows all origins in production; consider restricting AllowedOrigins")
                break
            }
        }
    }

    // Optional rate limiting (per-IP). Apply to API routes but not health endpoints.
    var apiRate func(http.Handler) http.Handler = func(h http.Handler) http.Handler { return h }
    if cfg.RateLimitEnabled {
        period, err := time.ParseDuration(cfg.RateLimitPeriod)
        if err != nil || period <= 0 {
            appLogger.Error("invalid rate limit period; disabling rate limit",
                slog.String("period", cfg.RateLimitPeriod),
                slog.Any("error", err))
        } else {
            apiRate = httprate.LimitByIP(cfg.RateLimit, period)
        }
    }

    // Health endpoints
    r.Group(func(r chi.Router) {
        r.Get("/healthz", handlers.Health)
        r.Get("/readyz", handlers.Ready)
    })

    // API v1
    r.Route("/api/v1", func(r chi.Router) {
        r.Use(apiRate)
        r.Get("/ping", handlers.Ping)
        r.Post("/echo", handlers.Echo)
    })

    // Swagger UI (generated docs). Available at /swagger/index.html
    // The docs are generated by running `swag init` (see README).
    // The URL param points to where the `doc.json` is served.
    docs.SwaggerInfo.Title = "Init Codex API"
    docs.SwaggerInfo.Version = "1.0"
    docs.SwaggerInfo.BasePath = "/"
    r.Get("/swagger/*", httpSwagger.Handler(
        httpSwagger.URL("/swagger/doc.json"),
        httpSwagger.DeepLinking(true),
        httpSwagger.DocExpansion("none"),
        httpSwagger.DomID("swagger-ui"),
    ))

    // Alias the Swagger UI under /api-docs as well.
    // Redirect /api-docs to the UI index for convenience.
    r.Get("/api-docs", func(w http.ResponseWriter, r *http.Request) {
        http.Redirect(w, r, "/api-docs/index.html", http.StatusTemporaryRedirect)
    })
    r.Get("/api-docs/*", httpSwagger.Handler(
        httpSwagger.URL("/swagger/doc.json"),
        httpSwagger.DeepLinking(true),
        httpSwagger.DocExpansion("none"),
        httpSwagger.DomID("swagger-ui"),
    ))

    // Root route
    r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        // Get logger from context for testing
        if l := pkglogger.FromContext(r.Context()); l != nil {
            // Simple test log with request ID (already attached from middleware)
            l.Info("This is a test log from root handler")
        }

        // Response
        response := fmt.Sprintf(`{"name":"%s","version":"%s","docs":"/swagger/index.html","status":"healthy"}`,
            "go-api", "1.0.0")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if _, err := w.Write([]byte(response)); err != nil {
            // Error level - something went wrong
            if l := pkglogger.FromContext(r.Context()); l != nil {
                l.With(slog.String("component", "API")).Error("failed to write root response",
                    slog.String("error", err.Error()),
                    slog.Int("response_size", len(response)),
                )
            }
        }
    })

    return r
}
