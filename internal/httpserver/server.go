package httpserver

import (
    "fmt"
    "log/slog"
    "net/http"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/go-chi/cors"
    "github.com/go-chi/httprate"
    httpSwagger "github.com/swaggo/http-swagger/v2"
    docs "github.com/mikko-kohtala/go-api/internal/docs"

    "github.com/mikko-kohtala/go-api/internal/config"
    "github.com/mikko-kohtala/go-api/internal/handlers"
)

// NewRouter assembles the chi router with middleware and routes.
func NewRouter(cfg *config.Config, logger *slog.Logger) http.Handler {
    r := chi.NewRouter()

    // Core middleware (place timeout early to bound all work)
    r.Use(middleware.Timeout(cfg.RequestTimeout))
    r.Use(RequestID)
    r.Use(middleware.RealIP)
    r.Use(LoggingMiddleware(logger))
    r.Use(middleware.Recoverer)
    r.Use(middleware.Compress(5))

    // CORS
    r.Use(cors.Handler(cors.Options{
        AllowedOrigins:   cfg.CORSAllowedOrigins,
        AllowedMethods:   cfg.CORSAllowedMethods,
        AllowedHeaders:   cfg.CORSAllowedHeaders,
        ExposedHeaders:   []string{"Link"},
        AllowCredentials: false,
        MaxAge:           300,
    }))
    // Warn if permissive CORS in production
    if cfg.Env == "production" || cfg.Env == "prod" {
        for _, o := range cfg.CORSAllowedOrigins {
            if o == "*" {
                logger.Warn("CORS allows all origins in production; consider restricting AllowedOrigins")
                break
            }
        }
    }

    // Optional rate limiting (per-IP)
    if cfg.RateLimitEnabled {
        period, err := time.ParseDuration(cfg.RateLimitPeriod)
        if err != nil || period <= 0 {
            logger.Error("invalid rate limit period; disabling rate limit",
                slog.String("period", cfg.RateLimitPeriod),
                slog.Any("error", err))
        } else {
            r.Use(httprate.LimitByIP(cfg.RateLimit, period))
        }
    }

    // Health endpoints
    r.Group(func(r chi.Router) {
        r.Get("/healthz", handlers.Health)
        r.Get("/readyz", handlers.Ready)
    })

    // API v1
    r.Route("/api/v1", func(r chi.Router) {
        r.Get("/ping", handlers.Ping)
        r.Post("/echo", handlers.Echo)
    })

    // Swagger UI (generated docs). Available at /swagger/index.html
    // The docs are generated by running `swag init` (see README).
    // The URL param points to where the `doc.json` is served.
    docs.SwaggerInfo.Title = "Init Codex API"
    docs.SwaggerInfo.Version = "1.0"
    docs.SwaggerInfo.BasePath = "/"
    r.Get("/swagger/*", httpSwagger.Handler(
        httpSwagger.URL("/swagger/doc.json"),
        httpSwagger.DeepLinking(true),
        httpSwagger.DocExpansion("none"),
        httpSwagger.DomID("swagger-ui"),
    ))

    // Root route
    r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(fmt.Sprintf(`{"name":"%s","version":"%s","docs":"/swagger/index.html"}`,
            "init-codex", "1.0.0")))
    })

    return r
}
