package httpserver

import (
    "fmt"
    "log/slog"
    "net/http"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/go-chi/cors"
    "github.com/go-chi/httprate"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    httpSwagger "github.com/swaggo/http-swagger/v2"
    docs "github.com/mikko-kohtala/go-api/internal/docs"

    "github.com/mikko-kohtala/go-api/internal/config"
    "github.com/mikko-kohtala/go-api/internal/handlers"
    "github.com/mikko-kohtala/go-api/internal/logging"
)

// NewRouter assembles the chi router with middleware and routes.
func NewRouter(cfg *config.Config, logger *slog.Logger) http.Handler {
    r := chi.NewRouter()

    // Core middleware (place timeout early to bound all work)
    r.Use(middleware.Timeout(cfg.RequestTimeout))
    r.Use(BodyLimit(cfg.BodyLimitBytes))
    r.Use(RequestID)
    r.Use(middleware.RealIP)
    // Compression level is configurable
    r.Use(middleware.Compress(cfg.CompressionLevel))
    
    // Observability middleware
    if cfg.MetricsEnabled {
        r.Use(MetricsMiddleware)
    }
    if cfg.TracingEnabled {
        r.Use(TracingMiddleware)
    }
    
    r.Use(LoggingMiddleware(logger))
    r.Use(middleware.Recoverer)

    // CORS
    r.Use(cors.Handler(cors.Options{
        AllowedOrigins:   cfg.CORSAllowedOrigins,
        AllowedMethods:   cfg.CORSAllowedMethods,
        AllowedHeaders:   cfg.CORSAllowedHeaders,
        ExposedHeaders:   []string{"Link"},
        AllowCredentials: false,
        MaxAge:           300,
    }))
    // Warn if permissive CORS in production
    if cfg.Env == "production" || cfg.Env == "prod" {
        for _, o := range cfg.CORSAllowedOrigins {
            if o == "*" {
                logger.Warn("CORS allows all origins in production; consider restricting AllowedOrigins")
                break
            }
        }
    }

    // Optional rate limiting (per-IP). Apply to API routes but not health endpoints.
    var apiRate func(http.Handler) http.Handler = func(h http.Handler) http.Handler { return h }
    if cfg.RateLimitEnabled {
        period, err := time.ParseDuration(cfg.RateLimitPeriod)
        if err != nil || period <= 0 {
            logger.Error("invalid rate limit period; disabling rate limit",
                slog.String("period", cfg.RateLimitPeriod),
                slog.Any("error", err))
        } else {
            apiRate = httprate.LimitByIP(cfg.RateLimit, period)
        }
    }

    // Health endpoints
    r.Group(func(r chi.Router) {
        r.Get("/healthz", handlers.Health)
        r.Get("/readyz", handlers.Ready)
    })

    // Metrics endpoint (if enabled)
    if cfg.MetricsEnabled {
        r.Get(cfg.MetricsPath, promhttp.Handler().ServeHTTP)
    }

    // API v1
    r.Route("/api/v1", func(r chi.Router) {
        r.Use(apiRate)
        r.Get("/ping", handlers.Ping)
        r.Post("/echo", handlers.Echo)
    })

    // Swagger UI (generated docs). Available at /swagger/index.html
    // The docs are generated by running `swag init` (see README).
    // The URL param points to where the `doc.json` is served.
    docs.SwaggerInfo.Title = "Init Codex API"
    docs.SwaggerInfo.Version = "1.0"
    docs.SwaggerInfo.BasePath = "/"
    r.Get("/swagger/*", httpSwagger.Handler(
        httpSwagger.URL("/swagger/doc.json"),
        httpSwagger.DeepLinking(true),
        httpSwagger.DocExpansion("none"),
        httpSwagger.DomID("swagger-ui"),
    ))

    // Alias the Swagger UI under /api-docs as well.
    // Redirect /api-docs to the UI index for convenience.
    r.Get("/api-docs", func(w http.ResponseWriter, r *http.Request) {
        http.Redirect(w, r, "/api-docs/index.html", http.StatusTemporaryRedirect)
    })
    r.Get("/api-docs/*", httpSwagger.Handler(
        httpSwagger.URL("/swagger/doc.json"),
        httpSwagger.DeepLinking(true),
        httpSwagger.DocExpansion("none"),
        httpSwagger.DomID("swagger-ui"),
    ))

    // Root route
    r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if _, err := w.Write([]byte(fmt.Sprintf(`{"name":"%s","version":"%s","docs":"/swagger/index.html"}`,
            "go-api", "1.0.0"))); err != nil {
            // Log write error via request-scoped logger if present
            if l := logging.FromContext(r.Context()); l != nil {
                l.Error("failed to write root response", slog.String("error", err.Error()))
            }
        }
    })

    return r
}
